//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: PC Model00p Template
//   Authors: HeyThereCoffeee, Amphos
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

struct LTString {
	ushort Length;
	char Value[Length];
};

struct LTUV {
	float u,v;
};

// Divide by 64
struct LTCompressedVector {
	short x,y,z;
};

struct LTVector {
	float x,y,z;
};

// Divide by 0x7FFF
struct LTCompressedQuat {
	short x,y,z,w;
};

struct LTQuat {
	float x,y,z,w;
};

string ReadCompressedVec(LTCompressedVector &vec)
{
	string str;
	SPrintf(str, "%f, %f, %f", (float)vec.x/64, (float)vec.y/64, (float)vec.z/64);
	return str;
}

string ReadCompressedRotation(LTCompressedQuat &rot)
{
	string str;
	SPrintf(str, "%f, %f, %f, %f", (float)rot.w/32768, (float)rot.x/32768, (float)rot.y/32768, (float)rot.z/32768);
	return str;
};

struct LTMatrix {
	LTQuat m[4];
};

struct Header {
	char Format[4];

	if (Format == "LDOM") {
		BigEndian();
	}

	int Version;
	int KeyframeCount;
	int AnimationCount;
	int NodeCount;
	int PieceCount;
	int ChildModelCount; // For some reason this always includes the current model, so it's always +1 more!
	int LODCount;
	int SocketCount;
	int AnimationWeightCount;
	int AnimationHeaderCount; // Use to be AnimationBindingCount...
	int StringDataLength; // Length in bytes of the text section
	int PhysicsWeightCount;
	int PhysicsShapeCount;
	int Unk12;
	int BallAndSocketContraintCount; // Not confirmed
	int StiffSpringConstraintCount;
	int HingeConstraintCount;
	int LimitedHingeConstraintCount;
	int RagdollConstraintCount;
	int WheelConstraintCount;
	int PrismaticConstraintCount;
	int AnimationDataLength;// Maybe Mesh or Animation Data?
	char StringList[StringDataLength];
};

Header hdr;

string ReadStringIndex(uint idx)
{
	char str[256];
	Memcpy(str, hdr.StringList, 255, 0, idx); // Strncpy doesn't work for some reason
	return str;
}

struct Transform {
	LTVector Position;
	LTCompressedQuat Rotation;
};

struct TransformNoRotation {
	LTVector Position;
};

struct TransformNoPosition {
	LTCompressedQuat Rotation;
};

// Forward
struct AnimationHeader;

//struct Animation (int NodeCount, AnimationHeader &animHdr) {
//};

struct AnimationHeader(int NodeCount) {
	ushort size_a;
	ushort size_b;

	struct AnimationKey {
		short a, b;
	} nodes[NodeCount];
};

struct AnimationKeyframe {
	int Time;
	int StringOffset;
};

struct AnimationInfo {
	LTVector Dims;
	float Radius;
	int NameOffset <read=ReadStringIndex>;
	int InterpTime;
	int SchemaIndex;
	int DataPosition;
	int IsCompressed;
	int KeyframeCount;
	AnimationKeyframe Keyframes[KeyframeCount];
};

struct Piece {
	int Unk[18];
	char Unk;
	char TextureIndex;
	char Translucent;
	char CastsShadow;
};

struct Test {
	int Here;
};

struct AnimSchema {
	char Data;
};

struct AnimData {
	char Data;
};

struct ChildModel {
	LTString Name;
};

struct ChildModelHeader {
	int ChildModelCount;
	ChildModel ChildModels[ChildModelCount - 1] <optimize=false>;
};

struct ChildModelHeaderv34 {
	int ChildModelCount;
	// Can't find a v34 model with child models, so this is just a guess!
	ChildModel ChildModels[ChildModelCount] <optimize=false>;
};

struct NodeWeight {
	char Physics;
	// Differences from 1.0/0.0?
	float VelocityGain;
	float HierachyGain;
};

struct PhysicsWeightSet (int Count) {
	int NameOffset;
	NodeWeight NodeWeights[Count];
};

// Unknown physics properties for now
struct Physics0x2 { // box
	float mass, density, unk;
	LTVector dimensions;
};

struct Physics0x3 { // sphere
	float mass, density, radius;
};

struct Physics0x5 { // meta subshape offset?
	LTVector offset;
	LTQuat rotation;
};

struct Physics0x6 { // meta shape count?
	int count;
};

struct Physics0x7 { // capsule
	float mass, density, radius;
	// TODO: test if x/z have interesting properties
	LTVector length; // y = length/2
	LTVector length; // y = -length/2
};

struct PhysicsShape {
	char ShapeIndex;
	LTVector Offset;
	LTQuat Orientation;

	float Cor;
	float Friction;

	int CollisionGroup; // Maybe CollisionGroup

	/*
	basically there's always at least one shape in each of these.
	if it's not meta shape 6 there's only 1, no problem.
	if it is meta shape 6, that's the count of how many shapes there are
	subsequent shapes are composed of a shape and a meta shape 5 for the offset
	the final shape has no following offset, and is assumed [0, 0, 0]
	*/
	local uint shape_count=1;
	while(shape_count-->0) //while((temp=ReadUInt())<=7 && temp>0)
	{
		int NodeIndex;

		switch(NodeIndex)
		{
			case 0x2:
				Physics0x2 physics_obb;
				break;

			case 0x3:
				Physics0x3 physics_sphere;
				break;

			case 0x5:
				Physics0x5 _5; // meta shape; sub-shape relative position/rotation?
				break;

			case 0x6:
				Physics0x6 _6; // meta shape; real shape count?
				shape_count+=_6.count*2-1;
				break;

			case 0x7:
				Physics0x7 physics_capsule;
				break;
		}
	}
};

struct PhysicsConstraintData {
	int Type;
	int NodeIndex1, NodeIndex2;
	//int Shape2Index;
	if (Type == 4) { // Ragdoll constraint
		float Data[24];
		float Friction;
	} else if (Type == 3) { // Limited Hinge Constraint
		float Data[18];
		float Friction;
		float Unk1;
		float Unk2;
	}
};

struct PhysicsHeader {
	int VisNode;
	float VisRadius;
	int ShapeCount;
	PhysicsShape Shapes[ShapeCount] <optimize=false>;
	int ConstraintCount;
	PhysicsConstraintData ConstraintData[ConstraintCount] <optimize=false>;
	int WeightSetCount;
	PhysicsWeightSet WeightSets(ShapeCount)[WeightSetCount] <optimize=false>;
};

struct AnimationWeightSet (int NodeCount) {
	// Actually NameOffset
	int NameOffset;
	int Unk; // ?
	float Weights[NodeCount];
};

struct AnimationWeightSetHeader (int NodeCount) {
	int Count;
	AnimationWeightSet WeightSets(NodeCount)[Count] <optimize=false>;
};

struct LODInfo {
	float LodDistance;
	char TextureIndex;
	char Translucent;
	char CastShadow;
	int PieceCount;
	int PieceIndexes[PieceCount];
};

struct SubLODInfo {
	float LodDistance;
	char TextureIndex;
	char Translucent;
	char CastShadow;
	int Unk1;
};

struct LODGroup {
	int NameOffset;
	int LODCount;
	LODInfo LODInfoData[LODCount] <optimize=false>;
};

struct LODGroupHeader {
	int LODGroupCount;
	LODGroup Groups[LODGroupCount] <optimize=false>;
};

struct GeometryHeader {
	int Unk3; // hasMeshData + 1; if == 1, mesh data is in external .Mesh00p file
	int PieceCount;
	int TotalLodCount;
};

struct Mesh {
	LTVector Vertex;
	LTVector Normals;
	LTUV UVs;
	LTVector Unk1;
	LTVector Unk4;
	uchar WeightInfo[3];
	uchar Padding;
	uchar NodeIndexes[3];
	uchar Padding2;
};

struct Meshv34 {
	LTVector Vertex;
	LTVector Normals;
	LTUV UVs;
	LTVector Unk1;
	LTVector Unk4;
	uchar Colour[4];
	uchar WeightInfo[3];
	uchar Padding;
	uchar NodeIndexes[3];
	uchar Padding2;
};

struct MeshHeader (int Version) {
	int LODCount; // unknown
	int TextureCount;

	// DataLength / 64 = MeshData
	int DataLength;
	// DataCount / 2 = tri-fs count
	int IndexListLength;

	if (Version == 34) {
		Meshv34 MeshData[DataLength/68];
	} else {
		Mesh MeshData[DataLength/64];
		//Meshv34 MeshData[DataLength/68];
	}

	short IndexList[IndexListLength/2]; // DataCount in bytes
};

struct ContainsGeometry {
	char Flag;
};

struct Socket {
	int NodeIndex;
	int NameOffset;
	LTQuat Rotation;
	LTVector Position;
	float Scale;
};

struct SocketHeader {
	int SocketCount;
	Socket Sockets[SocketCount] <optimize=false>;
};

// Related to Deformers
struct MeshInfo {
	int MeshDataStart;
	int MeshDataCount;
	//int IndexListStart;
	//int IndexListCount;
	int MeshDataSize;
	int IndexListPosition;
	//int MeshDataPosition; // Maybe?
	int Unk;
	int TriangleCount;
	int MaterialIndex;
	int InfluenceCount;
	int Unk; // VertexFormatDef index?
	char NodeIndexes[InfluenceCount];
};

struct AfterMesh {
	int Unk; // vertex format def count

	struct VertexFormatDef {
		int ByteDataCount; // size in bytes
		uchar ByteList[ByteDataCount]; // properties[ByteDataCount/sizeof(VertexProp)];
	} vertex_defs[Unk] <optimize=false>;

	// Mesh Info?
	int MeshInfoCount;
	MeshInfo Info[MeshInfoCount] <optimize=false>;
};

struct Node {
	int NameOffset <read=ReadStringIndex>;
	short Index; // Node Index
	char Flag; // Node Flags
	LTVector Location;
	LTQuat Rotation;
	int ChildCount;
};

Node Nodes[hdr.NodeCount];

float unk;
AnimationHeader animHeaders(hdr.NodeCount)[hdr.AnimationHeaderCount] <bgcolor=cLtRed>;

local uint anim_data_pos=FTell();
AnimData skip2[hdr.AnimationDataLength];

AnimationInfo animInfo[hdr.AnimationCount] <bgcolor=cLtYellow, optimize=false>;
local uint anim_info_pos=FTell();

void InsertCompressedVector(byte is_compressed)
{
	if (is_compressed)
		LTCompressedVector vec <read=ReadCompressedVec>;
	else
		LTVector vec;
}

struct Animation(AnimationInfo &info, AnimationHeader &header)
{
	local uint j=0;
	for(j=0; j<hdr.NodeCount; ++j)
	{
		if (header.nodes[j].a<-1)
			InsertCompressedVector(info.IsCompressed);

		if (header.nodes[j].b<-1)
			LTCompressedQuat rot <read=ReadCompressedRotation>;
	}

	local uint k=0;
	for(j=0; j<info.KeyframeCount; ++j)
	{
		for(k=0; k<hdr.NodeCount; ++k)
		{
			if ((header.nodes[k].a & 0x8000)==0)
				InsertCompressedVector(info.IsCompressed);

			if ((header.nodes[k].b & 0x8000)==0)
				LTCompressedQuat rot <read=ReadCompressedRotation>;
		}
	}
};

local uint i=0;
for(i=0; i<hdr.AnimationCount; ++i)
{
	FSeek(anim_data_pos+animInfo[i].DataPosition);
	Animation anims(animInfo[i], animHeaders[animInfo[i].SchemaIndex]) <bgcolor=cLtGreen>;
}

FSeek(anim_info_pos);

AnimationWeightSetHeader animWeightSetHeader(hdr.NodeCount);

SocketHeader socketHeader;

if (hdr.Version == 34) {
	ChildModelHeaderv34 childModels;
} else {
	ChildModelHeader childModels;
}

ContainsGeometry hasGeometry;
if (!hasGeometry.Flag) return;

// Geometry related
PhysicsHeader PhysicsInfo;


LODGroupHeader lodGroupHeader;

GeometryHeader geometryHeader;

if (geometryHeader.Unk3 > 1)
{
	int unk;
	MeshHeader meshHeader(hdr.Version);
	AfterMesh Debug;

	int unk;
	MeshHeader meshHeader(hdr.Version);
	AfterMesh Debug;
}
else
{
	struct ExternalMeshRef
	{
		int a, b;
		LTString filename;
		int d;
	} externalMesh;
}